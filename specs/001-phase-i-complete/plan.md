# Implementation Plan: Complete Phase I with Intermediate & Advanced Features

**Branch**: `001-phase-i-complete` | **Date**: 2025-12-29 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/specs/001-phase-i-complete/spec.md`

**Note**: This plan covers the enhanced Phase I with Basic (P1), Intermediate (P2), and Advanced (P3) features for the Intelligent Todo CLI application.

## Summary

This implementation extends the basic console todo application to include intermediate organizational features (priorities, tags, search, filter, sort) and advanced intelligent capabilities (recurring tasks, due dates with browser notifications, voice input, email notifications). The system will remain a Python console application with in-memory storage for Phase I, but will incorporate external dependencies for P2/P3 features where justified. All code will be generated by Claude Code following strict spec-driven development principles.

**Primary Requirements**: 8 user stories spanning P1-P3 priorities, 88 functional requirements, 20 measurable success criteria
**Technical Approach**: Python 3.13+ with standard library for P1 features, justified external dependencies for P2/P3 features (desktop notifications, voice transcription, email via SMTP)

## Technical Context

**Language/Version**: Python 3.13+
**Primary Dependencies**:
- P1 (Basic): Python standard library only
- P2 (Intermediate): `plyer` for desktop notifications (cross-platform)
- P3 (Advanced): `SpeechRecognition` + `pyaudio` for voice input, `smtplib` (standard library) for email

**Storage**: In-memory (Python list data structures) - Phase I only
**Testing**: pytest with coverage ≥80%
**Target Platform**: Desktop (Windows, macOS, Linux) with Python 3.13+ runtime
**Project Type**: Single console application
**Performance Goals**:
- Search/filter/sort: <1 second for 1000 tasks
- Voice transcription: <5 seconds for 30-second utterances
- Browser notifications: <1 minute trigger latency
- App startup: <3 seconds

**Constraints**:
- No persistent storage (in-memory only for Phase I)
- Single-user, single-threaded
- Console interface only (no GUI)
- All code Claude Code-generated from specs

**Scale/Scope**:
- Target: 1000+ tasks without performance degradation
- 9 menu options
- 88 functional requirements
- 8 user stories (P1-P3)

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Principle I: Spec-Driven Development ✅
- **Status**: PASS
- **Evidence**: All requirements traced to spec.md with clarifications documented
- **Enforcement**: All source files will include `@spec:` comments referencing spec.md

### Principle II: AI-Native Architecture ✅
- **Status**: PASS
- **Evidence**: All code generated by Claude Code via /sp.* commands
- **Enforcement**: PHR created for each development session

### Principle III: Progressive Evolution ✅
- **Status**: PASS
- **Evidence**: Phase I requirements explicitly defined (Basic + Intermediate + Advanced)
- **Phase Gate**: Must pass Phase I → Phase II gate before advancing to web app

### Principle IV: Cloud-Native and Event-Driven Focus ⏸️
- **Status**: NOT APPLICABLE (Phase I)
- **Rationale**: Console app with in-memory storage; cloud-native patterns start in Phase II

### Principle V: Reusability and Intelligence ✅
- **Status**: PASS
- **Evidence**: Using existing skills (sp.specify, sp.clarify, sp.plan, sp.tasks, sp.implement)
- **Future**: Voice input and notification patterns may become reusable blueprints for Phase II

### Principle VI: Security and User Isolation ⏸️
- **Status**: NOT APPLICABLE (Phase I)
- **Rationale**: Single-user console app; security requirements start in Phase II (JWT auth)

### Principle VII: Automated Compliance Verification ✅
- **Status**: PASS
- **Plan**: pytest with coverage plugin, spec traceability validation script
- **Target**: ≥80% test coverage, 100% spec traceability

### Phase I Requirements Compliance ✅

**Feature Scope**:
- ✅ All 5 Basic features defined (FR-001 through FR-016)
- ✅ Additional Intermediate features (priorities, tags, search, filter, sort)
- ✅ Additional Advanced features (recurring, due dates, voice, email)

**Testing**:
- ✅ Unit tests planned for task CRUD and organizational features
- ✅ Integration tests planned for CLI commands and feature interactions
- ✅ Coverage target: ≥80%

**Success Criteria**:
- ✅ All features functional (87 functional requirements)
- ✅ Tests pass (pytest suite)
- ✅ Spec traceability: 100% (@spec comments)

**Gate Status**: ✅ Ready for Phase 0 research

## Project Structure

### Documentation (this feature)

```text
specs/001-phase-i-complete/
├── spec.md              # Feature specification with 8 user stories, 88 FRs
├── plan.md              # This file (/sp.plan command output)
├── research.md          # Phase 0 output - technology evaluation
├── data-model.md        # Phase 1 output - entity definitions
├── quickstart.md        # Phase 1 output - setup and usage
├── contracts/           # Phase 1 output - interface contracts
│   ├── task_service.py  # TaskList service interface
│   ├── cli_commands.py  # CLI command contracts
│   ├── notifications.py # Notification system interface
│   └── voice_input.py   # Voice input interface
├── checklists/          # Quality validation checklists
│   └── requirements.md  # Spec quality checklist (already exists)
└── tasks.md             # Phase 2 output (/sp.tasks command - NOT created by /sp.plan)
```

### Source Code (repository root)

```text
src/
├── models/
│   ├── __init__.py
│   ├── task.py                  # Task dataclass with all attributes
│   ├── priority.py              # Priority enum (High, Medium, Low)
│   ├── recurrence.py            # Recurrence pattern definitions
│   └── notification.py          # Notification model
│
├── services/
│   ├── __init__.py
│   ├── todo_list.py             # TaskList service (CRUD + search/filter/sort)
│   ├── notification_service.py  # Browser notification management
│   ├── email_service.py         # Email notification sending
│   ├── voice_service.py         # Voice input transcription
│   └── recurrence_service.py    # Recurring task date calculation
│
├── cli/
│   ├── __init__.py
│   ├── main.py                  # Application entry point and main loop
│   ├── menu.py                  # Menu display and selection
│   ├── commands.py              # Command handlers for all 9 menu options
│   └── input_validators.py     # Input validation utilities
│
└── lib/
    ├── __init__.py
    ├── date_utils.py            # Date parsing and validation
    └── notification_utils.py    # Notification platform detection

tests/
├── unit/
│   ├── test_task.py             # Task model tests
│   ├── test_priority.py         # Priority enum tests
│   ├── test_todo_list.py        # TaskList service tests
│   ├── test_recurrence.py       # Recurrence calculation tests
│   └── test_date_utils.py       # Date utility tests
│
├── contract/
│   ├── test_task_service_contract.py      # TaskList interface contract
│   ├── test_cli_commands_contract.py      # CLI command contracts
│   └── test_notification_contract.py      # Notification interface contract
│
└── integration/
    ├── test_cli_flow.py         # End-to-end CLI command flows
    ├── test_recurring_tasks.py  # Recurring task integration
    ├── test_notifications.py    # Notification trigger integration
    └── test_voice_input.py      # Voice input integration

config/
└── .env.example                 # Example environment variables for email

pyproject.toml                   # UV project configuration
README.md                        # Project documentation
```

**Structure Decision**: Single project structure selected as this is a console application. The modular layout (models, services, CLI, lib) provides clear separation of concerns while maintaining simplicity appropriate for Phase I. Tests are organized by type (unit, contract, integration) to support comprehensive validation of all 88 functional requirements.

## Complexity Tracking

> **No violations identified** - Phase I follows constitution standards

## Phase 0: Outline & Research

### Research Questions

Based on Technical Context unknowns and specification requirements:

1. **Desktop Notification Libraries**: Which Python library provides best cross-platform support for desktop notifications on Windows, macOS, and Linux?

2. **Voice Input Technology**: What is the best approach for voice-to-text transcription in a Python console app (local library vs. external API)?

3. **Email Configuration**: What is the recommended pattern for managing SMTP configuration (environment variables, config file, or user prompts)?

4. **Month-End Date Handling**: What is the Python standard library approach for calculating month-end dates in recurring task logic?

5. **Testing Framework Selection**: pytest vs unittest - which provides better support for our testing needs (coverage, fixtures, parameterized tests)?

### Research Tasks Dispatched

I'll generate research.md addressing all unknowns before proceeding to Phase 1 design.

## Phase 1: Design & Contracts

*Prerequisites: research.md complete*

### Design Artifacts to Generate

1. **data-model.md**: Entity definitions for Task, Priority, Recurrence, Notification, EmailConfig
2. **contracts/**: Python interface definitions for all services
3. **quickstart.md**: Setup instructions and basic usage guide

### Agent Context Update

After Phase 1 completion, will run:
```bash
.specify/scripts/bash/update-agent-context.sh claude
```

This will update `CLAUDE.md` with:
- New external dependencies (plyer, SpeechRecognition, pyaudio)
- Testing framework choice (pytest)
- Module structure conventions

---

**Plan Status**: Ready for Phase 0 research execution

**Next Steps**:
1. Generate research.md (addresses all technology choices)
2. Generate data-model.md (defines all entities from spec)
3. Generate contracts/ (service interface definitions)
4. Generate quickstart.md (setup and usage documentation)
5. Update agent context (CLAUDE.md)
6. Report completion and readiness for /sp.tasks
