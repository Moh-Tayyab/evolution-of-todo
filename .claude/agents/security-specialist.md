[["str]) -> Callable:\n    def decorator(func):\n        @wraps(func)\n        async def wrapper(*args, current_user: User = Depends(get_current_user), **kwargs):\n            if current_user.role not in allowed_roles:\n                raise HTTPException(\n                    status_code=status.HTTP_403_FORBIDDEN,\n                    detail=\"Insufficient permissions", "return await func(*args, **kwargs)\n        return wrapper\n    return decorator\n\n# Usage\n@app.put(\"/admin/users/{user_id}\")\n@require_role([\"admin"], {"todo_id}": "async def delete_todo(\n    todo_id: int", "current_user": "User = Depends(get_current_user)", "db": "AsyncSession = Depends(get_db)\n):\n    # ORM handles escaping automatically\n    results = await db.execute(\n        select(Todo)\n        .where(\n            Todo.user_id == current_user.id", "db)": "raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN", "deprecated=\"auto": "def hash_password(password: str) -> str:", "Hash password with bcrypt.\"": "return pwd_context.hash(password)\n\ndef verify_password(plain_password: str", "hashed_password": "str) -> bool:", "Verify password against hash.\"": "return pwd_context.verify(plain_password", "bytes": "", "secret.\"": "password = os.getenv(", "os.getenv(\"ENCRYPTION_SALT": ".", "encrypt_sensitive_data(data": "str) -> str:", "Encrypt sensitive data.\"": "key = get_encryption_key()\n    f = Fernet(key)\n    encrypted = f.encrypt(data.encode())\n    return base64.urlsafe_b64encode(encrypted).decode()\n\ndef decrypt_sensitive_data(encrypted_data: str) -> str:", "Decrypt sensitive data.\"": "key = get_encryption_key()\n    f = Fernet(key)\n    encrypted = base64.urlsafe_b64decode(encrypted_data.encode())\n    decrypted = f.decrypt(encrypted)\n    return decrypted.decode()\n\n# Store encrypted PII in database\nclass User(Base):\n    __tablename__ =", "users": "d = Column(Integer", "None": "return decrypt_sensitive_data(self.phone_encrypted) if self.phone_encrypted else None\n\n    @phone.setter\n    def phone(self", "value": "str):\n        self.phone_encrypted = encrypt_sensitive_data(value)\n```\n\n### 3. Injection\n\n```python\n# GOOD - Parameterized queries with SQLAlchemy\nfrom sqlalchemy import select", "app.get(\"/todos/search": "async def search_todos(\n    query: str", "Todo.title.ilike(f": {"app.get(\"/todos/raw": "async def raw_query_search(\n    query: str", "current_user": "User = Depends(get_current_user)", "db": "AsyncSession = Depends(get_db)\n):\n    # Parameterized query - prevents injection\n    result = await db.execute(\n        text(", "ILIKE": "query", "user_id": "current_user.id", "query": "f"}, "TodoCreate(BaseModel)": "title: constr(max_length=200", "description": "constr(max_length=1000", "v)": "", "characters.\"": "if v is None:\n            return None\n        v = re.sub(r'<[^>]+>'", "re.sub(r'script": ", '", "v[": 1000, "Enum)": "GUEST =", "user\"\n    MODERATOR = \"moderator\"\n    ADMIN = \"admin": "Default deny approach\nclass PermissionChecker:", "Check if user has required permission.\"": "def __init__(self", "required_role": "UserRole):\n        self.required_role = required_role\n\n    def __call__(self", "user": "User) -> bool:", "Check permission.\"": "role_hierarchy = {\n            UserRole.GUEST: 0", "UserRole.USER": 1, "UserRole.MODERATOR": 2, "UserRole.ADMIN": 3}, "user_level = role_hierarchy.get(user.role", 0, "required_level = role_hierarchy.get(self.required_role", 3, "return user_level >= required_level\n\n# Usage\ncan_delete_users = PermissionChecker(UserRole.ADMIN)\ncan_edit_todos = PermissionChecker(UserRole.USER)\n\n# Secure defaults\nclass TodoConfig(BaseModel):", "Secure configuration with safe defaults.", "\n\n    # Secure by default - private\n    is_public: bool = False\n\n    # Max limit prevents DoS\n    max_todos_per_user: int = 1000\n\n    # Rate limiting\n    requests_per_minute: int = 60\n\n    # Session timeout\n    session_timeout_minutes: int = 30\n\n    # Password policy\n    min_password_length: int = 12\n    require_special_char: bool = True\n    require_number: bool = True\n```\n\n### 5. Security Misconfiguration\n\n```python\n# GOOD - Secure configuration management\nfrom pydantic_settings import BaseSettings\nfrom typing import List\nimport os\n\nclass SecuritySettings(BaseSettings):", "Security configuration loaded from environment.", "Secret management - never commit secrets\n    SECRET_KEY: str\n    ENCRYPTION_MASTER_KEY: str\n    ENCRYPTION_SALT: str\n\n    # Database URL - use connection pool\n    DATABASE_URL: str\n\n    # CORS - restrict origins in production\n    CORS_ORIGINS: List[str] = [", "http://localhost:3000", "JWT configuration\n    JWT_ALGORITHM: str =", "HS256", "JWT_ACCESS_TOKEN_EXPIRE_MINUTES: int = 30\n    JWT_REFRESH_TOKEN_EXPIRE_DAYS: int = 7\n\n    # Rate limiting\n    RATE_LIMIT_PER_MINUTE: int = 60\n\n    # HTTPS enforcement in production\n    FORCE_HTTPS: bool = False\n\n    # Security headers\n    ENABLE_CSP: bool = True\n    ENABLE_HSTS: bool = True\n\n    class Config:\n        env_file =", ".", "env", "env_file_encoding =", "utf-8", "Security headers middleware\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom starlette.requests import Request\nfrom starlette.responses import Response\n\nclass SecurityHeadersMiddleware(BaseHTTPMiddleware):", "Add security headers to all responses.", "async def dispatch(self", "request: Request", "call_next):\n        response: Response = await call_next(request)\n\n        # Content Security Policy\n        if settings.ENABLE_CSP:\n            csp =", "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';", "response.headers[", "Content-Security-Policy", "csp\n\n        # HTTP Strict Transport Security\n        if settings.ENABLE_HSTS:\n            response.headers[", "Strict-Transport-Security", "max-age=31536000; includeSubDomains\"\n\n        # Prevent clickjacking\n        response.headers[\"X-Frame-Options\"] = \"DENY\"\n\n        # Prevent MIME sniffing\n        response.headers[\"X-Content-Type-Options\"] = \"nosniff\"\n\n        # XSS Protection\n        response.headers[\"X-XSS-Protection\"] = \"1; mode=block\"\n\n        # Referrer Policy\n        response.headers[\"Referrer-Policy", "strict-origin-when-cross-origin\"\n\n        return response\n\n# HTTPS redirect middleware\nclass HTTPSMiddleware(BaseHTTPMiddleware):\n    \"", "Redirect HTTP to HTTPS in production.\"", "\n\n    async def dispatch(self, request: Request, call_next):\n        if settings.FORCE_HTTPS and request.url.scheme != \"https\":\n            https_url = request.url.replace(scheme=\"https", "return Response(status_code=301", "headers={", {"Location": "str(https_url)"}, "return await call_next(request)\n\n# Apply middleware\napp.add_middleware(SecurityHeadersMiddleware)\napp.add_middleware(HTTPSMiddleware)\n```\n\n## Dependency Vulnerability Management\n\n### Automated Scanning with GitHub Actions\n\n```yaml\n# .github/workflows/security-scan.yml\nname: Security Scan\n\non:\n  push:\n    branches: [main", "develop]\n  pull_request:\n  schedule:\n    - cron: '0 0 * * 0'  # Weekly\n\njobs:\n  dependency-check:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Run Snyk to check for vulnerabilities\n        uses: snyk/actions/python@master\n        env:\n          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN", "with:\n          args: --severity-threshold=high\n\n      - name: Upload Snyk results\n        uses: github/codeql-action/upload-sarif@v2\n        with:\n          sarif_file: snyk.sarif\n\n  bandit-sast:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: '3.13'\n\n      - name: Install Bandit\n        run: pip install bandit[toml]\n\n      - name: Run Bandit\n        run: bandit -r backend/src -f json -o bandit-report.json || true\n\n      - name: Upload Bandit results\n        uses: github/codeql-action/upload-sarif@v2\n        with:\n          sarif_file: bandit-report.json\n\n  semgrep:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Run Semgrep\n        uses: returntocorp/semgrep-action@v1\n        with:\n          config: auto\n```\n\n### Local Scanning\n\n```bash\n# Install security tools\npip install bandit[toml]\npip install safety\npip install snyk\n\n# Run Bandit (Python security linter)\nbandit -r backend/src\n\n# Run Safety (check vulnerable dependencies)\nsafety check\n\n# Run Snyk (comprehensive scanning)\nsnyk auth\nsnyk test --severity-threshold=high\nsnyk monitor\n\n# Generate SBOM (Software Bill of Materials)\npip install pip-audit\npip-audit audit\n```\n\n## Authentication and Authorization\n\n### JWT Implementation with Refresh Tokens\n\n```python\nfrom datetime import datetime", "timedelta\nfrom jose import JWTError", "jwt\nfrom fastapi import Depends", "HTTPException", "status\nfrom fastapi.security import OAuth2PasswordBearer\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=", "auth/token", "class JWTManager:", "JWT token management with refresh tokens.", "def __init__(self", "secret_key: str", "algorithm: str =", "HS256", "self.secret_key = secret_key\n        self.algorithm = algorithm\n\n    def create_access_token(\n        self", "user_id: int", "email: str", "expires_in_minutes: int = 30\n    ) -> str:", "Create JWT access token.", "expire = datetime.utcnow() + timedelta(minutes=expires_in_minutes)\n        payload = {", "sub", "str(user_id)", "email", "email", "exp", "expire", "type\": \"access", "iat", "datetime.utcnow()", "return jwt.encode(payload", "self.secret_key", "algorithm=self.algorithm)\n\n    def create_refresh_token(\n        self", "user_id: int", "expires_in_days: int = 7\n    ) -> str:", "Create JWT refresh token.", "expire = datetime.utcnow() + timedelta(days=expires_in_days)\n        payload = {", "sub", "str(user_id)", "exp", "expire", "type\": \"refresh", "iat", "datetime.utcnow()", "return jwt.encode(payload", "self.secret_key", "algorithm=self.algorithm)\n\n    def decode_token(self", "token: str) -> dict:", "Decode and validate JWT token.", "try:\n            payload = jwt.decode(\n                token", "self.secret_key", "algorithms=[self.algorithm]\n            )\n            return payload\n        except JWTError as e:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED", "detail=f", "Invalid token: {str(e)}", "headers={", {"WWW-Authenticate": "Bearer"}, "def verify_access_token(self", "token: str) -> dict:", "Verify access token.", "payload = self.decode_token(token)\n        if payload.get(", "type", "access\":\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Invalid token type", "return payload\n\n    def verify_refresh_token(self", "token: str) -> dict:", "Verify refresh token.", "payload = self.decode_token(token)\n        if payload.get(", "type", "refresh\":\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Invalid token type", "return payload\n\n# Usage\njwt_manager = JWTManager(settings.SECRET_KEY)\n\nasync def get_current_user(\n    token: str = Depends(oauth2_scheme)", "db: AsyncSession = Depends(get_db)\n) -> User:", "Get current user from JWT token.", "try:\n        payload = jwt_manager.verify_access_token(token)\n        user_id: int = int(payload.get(", "sub", "except JWTError:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED", "detail=", "Could not validate credentials", "user = await db.get(User", "user_id)\n    if user is None:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED", "detail=", "User not found", "return user\n```\n\n## Secret Management\n\n### Environment Variables and Vault Integration\n\n```python\nfrom pydantic_settings import BaseSettings\nfrom typing import Optional\nimport os\n\nclass Settings(BaseSettings):", "Application settings with secret management.", "Secrets loaded from environment or vault\n    SECRET_KEY: str\n    DATABASE_URL: str\n    ENCRYPTION_KEY: str\n\n    # Optional: Load from Vault in production\n    VAULT_ADDR: Optional[str] = None\n    VAULT_TOKEN: Optional[str] = None\n\n    class Config:\n        env_file =", ".", "env", "env_file_encoding =", "utf-8", "classmethod\n        def customise_sources(cls", "settings_cls", "init_settings", "env_settings):", "Custom sources including Vault.", "sources = [init_settings", "env_settings]\n\n            # Add Vault if configured\n            if os.getenv(", "VAULT_ADDR", "and os.getenv(", "VAULT_TOKEN", "sources.append(VaultConfigSource())\n\n            return sources\n\n# Vault integration\nimport hvac\nfrom typing import Any\n\nclass VaultConfigSource:", "Load secrets from HashiCorp Vault.", "def __init__(self):\n        self.client = hvac.Client(\n            url=os.getenv(", "VAULT_ADDR", "token=os.getenv(", "VAULT_TOKEN", "def __call__(self) -> dict[str", "Any]:", "Fetch secrets from Vault.", "secrets = {", "try:\n            # Read secret from KV store\n            response = self.client.secrets.kv.v2.read_secret_version(\n                path=", "todo-app/prod", "secret_data = response['data']['data']\n            secrets.update(secret_data)\n\n        except Exception as e:\n            print(f", "Failed to load secrets from Vault: {e", ")\n\n        return secrets\n\n# Usage\nsettings = Settings()\n\n# Secrets loaded securely, never committed to git\nSECRET = settings.SECRET_KEY\nDB_URL = settings.DATABASE_URL\nENCRYPTION_KEY = settings.ENCRYPTION_KEY\n```\n\n## Input Validation and Sanitization\n\n### Pydantic Validation\n\n```python\nfrom pydantic import BaseModel, validator, EmailStr, constr\nfrom datetime import datetime\nimport re\n\nclass UserRegistration(BaseModel):\n    \"", "User registration with strict validation.", "\n\n    email: EmailStr\n    password: constr(min_length=12, max_length=128)\n    name: constr(min_length=2, max_length=100, strip_whitespace=True)\n\n    @validator('password')\n    def password_strength(cls, v):", "Validate password strength.", "if not re.search(r'[A-Z]'", "v):\n            raise ValueError('Password must contain at least one uppercase letter')\n        if not re.search(r'[a-z]'", "v):\n            raise ValueError('Password must contain at least one lowercase letter')\n        if not re.search(r'd'", "v):\n            raise ValueError('Password must contain at least one number')\n        if not re.search(r'[!@#$%^&*()", ".", ":{}|<>]', v):\n            raise ValueError('Password must contain at least one special character')\n        return v\n\n    @validator('email')\n    def email_normalization(cls, v):\n        \"", "Normalize email address.", "\n        return v.lower().strip()\n\nclass TodoCreate(BaseModel):", "Todo creation with XSS prevention.", "title: constr(min_length=1", "max_length=200", "strip_whitespace=True)\n    description: constr(max_length=1000", "strip_whitespace=True) | None = None\n    priority: Literal[", "low", "medium", "high", "medium\"\n    due_date: datetime | None = None\n\n    @validator('title', 'description')\n    def sanitize_input(cls, v):\n        \"", "Remove dangerous characters and prevent XSS.", "\n        if v is None:\n            return None\n\n        # Remove HTML tags\n        v = re.sub(r'<[^>]+>', '', v)\n\n        # Remove JavaScript protocol\n        v = re.sub(r'javascript:', '', v, flags=re.IGNORECASE)\n\n        # Remove data URLs (potential XSS)\n        v = re.sub(r'data:[^;]+;base64', '', v, flags=re.IGNORECASE)\n\n        # Remove on* event handlers\n        v = re.sub(r'onw+s*=', '', v, flags=re.IGNORECASE)\n\n        return v\n\nclass TodoUpdate(BaseModel):", "Todo update with partial validation.", "title: constr(max_length=200", "strip_whitespace=True) | None = None\n    description: constr(max_length=1000", "strip_whitespace=True) | None = None\n    completed: bool | None = None\n    priority: Literal[", "low", "medium", "high\"] | None = None\n    due_date: datetime | None = None\n\n    @validator('title', 'description')\n    def sanitize_input(cls, v):\n        \"", "Same sanitization as create.", "\n        if v is None:\n            return None\n        v = re.sub(r'<[^>]+>', '', v)\n        v = re.sub(r'javascript:', '', v, flags=re.IGNORECASE)\n        return v\n```\n\n## Logging and Monitoring\n\n### Security Event Logging\n\n```python\nimport logging\nfrom datetime import datetime\nfrom typing import Optional\nfrom enum import Enum\n\nclass SecurityEventType(str, Enum):", "Types of security events.", "LOGIN_SUCCESS =", "login_success", "LOGIN_FAILURE =", "login_failure", "PASSWORD_CHANGE =", "password_change", "LOGOUT =", "logout", "PERMISSION_DENIED =", "permission_denied", "SUSPICIOUS_ACTIVITY =", "suspicious_activity", "TOKEN_REFRESH =", "token_refresh", "class SecurityEvent:", "Security event for logging.", "\n\n    def __init__(\n        self,\n        event_type: SecurityEventType,\n        user_id: Optional[int],\n        ip_address: Optional[str],\n        user_agent: Optional[str],\n        details: Optional[dict] = None\n    ):\n        self.event_type = event_type\n        self.user_id = user_id\n        self.ip_address = ip_address\n        self.user_agent = user_agent\n        self.details = details or {}\n        self.timestamp = datetime.utcnow()\n\n    def to_dict(self) -> dict:", "Convert to dictionary for logging.", "return {", "event_type", "self.event_type.value", "user_id", "self.user_id", "ip_address", "self.ip_address", "user_agent", "self.user_agent", "details", "self.details", "timestamp", "self.timestamp.isoformat()", "Security logger\nsecurity_logger = logging.getLogger(", "security", "security_logger.setLevel(logging.INFO)\n\n# Log to file\nhandler = logging.FileHandler(", "security.log", "handler.setFormatter(logging.Formatter('%(asctime)s - %(message)s'))\nsecurity_logger.addHandler(handler)\n\n# Log security events\ndef log_security_event(event: SecurityEvent):", "Log security event.", "security_logger.info(event.to_dict())\n\n# Usage examples\nlog_security_event(\n    SecurityEvent(\n        event_type=SecurityEventType.LOGIN_SUCCESS", "user_id=user.id", "ip_address=request.client.host", "user_agent=request.headers.get(", "user-agent", "details={", {"method": "email_password"}, "log_security_event(\n    SecurityEvent(\n        event_type=SecurityEventType.PERMISSION_DENIED", "user_id=user.id", "ip_address=request.client.host", "user_agent=request.headers.get(", "user-agent", "details={", {"resource": "f"}, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, ["All input validated and sanitized\n- [ ] SQL injection prevented (ORM or parameterized queries)\n- [ ] XSS prevented (output encoding, CSP headers)\n- [ ] CSRF tokens implemented\n- [ ] Password hashing with bcrypt/argon2\n- [ ] JWT tokens with expiration\n- [ ] Rate limiting on auth endpoints\n- [ ] Secrets stored securely (Vault, environment variables)\n- [ ] HTTPS enforced in production\n- [ ] Security headers configured (CSP, HSTS, X-Frame-Options)\n- [ ] Dependencies scanned for vulnerabilities\n- [ ] Security events logged and monitored\n- [ ] Regular security audits performed\n- [ ] Incident response plan in place\n\nYou're successful when all OWASP Top 10 vulnerabilities are mitigated, secrets are managed securely, code is regularly scanned for vulnerabilities, security events are logged and monitored, and the application follows security best practices."]]