#!/usr/bin/env python3
# @spec: Git Hooks System for Evolution of Todo Project
# Post-execute hook: Custom commands after execute operations
#
# This is a custom hook that runs user-defined commands after executing
# specific operations (e.g., after running tests, after building, etc.).
#
# This hook is DISABLED by default. Enable it in config.yaml by setting:
#   post_execute:
#     enabled: true
#     commands:
#       - echo "Build complete!"
#       - npm run post-build
#
# Performance: Depends on configured commands
# Exit codes: 0 (success, always - don't block after execution)

from __future__ import annotations

import sys
import os
import subprocess
from pathlib import Path
from typing import List

# Add hooks utils to path
hooks_dir = Path(__file__).parent
utils_dir = hooks_dir / "utils"
sys.path.insert(0, str(utils_dir))

# Import utility modules
from logger import HookLogger
from config import HookConfig


def print_banner(logger: HookLogger) -> None:
    """
    Print the post-execute hook banner.

    Args:
        logger: HookLogger instance for output
    """
    logger.info("")
    logger.info("=" * 70)
    logger.info("  POST-EXECUTE HOOK - Custom Post-Execution Commands")
    logger.info("=" * 70)
    logger.info("")


def execute_commands(
    logger: HookLogger,
    commands: List[str],
    working_dir: Path
) -> bool:
    """
    Execute a list of shell commands.

    Args:
        logger: HookLogger instance for output
        commands: List of command strings to execute
        working_dir: Directory to execute commands in

    Returns:
        True if all commands succeeded, False if any failed
    """
    if not commands:
        logger.info("No commands configured")
        return True

    logger.sub_section(f"Running {len(commands)} Command(s)")

    all_passed = True

    for i, command in enumerate(commands, 1):
        logger.info(f"[{i}/{len(commands)}] Executing: {command}")

        try:
            result = subprocess.run(
                command,
                shell=True,  # Intentional: allow shell commands
                cwd=working_dir,
                capture_output=True,
                text=True,
                timeout=300  # 5 minute timeout per command
            )

            if result.returncode == 0:
                logger.success(f"Command succeeded: {command}")

                # Show output if verbose
                if logger.verbose and result.stdout:
                    logger.debug(result.stdout)
            else:
                logger.warning(f"Command failed: {command}")

                # Show error output
                if result.stderr:
                    logger.warning(result.stderr)
                if result.stdout:
                    logger.info(result.stdout)

                # Don't fail for post-execute, just warn
                all_passed = False

        except subprocess.TimeoutExpired:
            logger.warning(f"Command timed out after 5 minutes: {command}")
            all_passed = False
        except Exception as e:
            logger.warning(f"Command error: {e}")
            all_passed = False

    return all_passed


def main() -> int:
    """
    Main entry point for the post-execute hook.

    This hook runs user-defined commands after an operation completes.
    Commands are configured in config.yaml under post_execute.commands.

    Returns:
        Exit code: 0 (always success, don't block operations)
    """
    # Initialize logger
    logger = HookLogger(
        hook_name="post-execute",
        verbose=os.getenv("GIT_HOOKS_VERBOSE", "false").lower() == "true"
    )

    # Print banner
    print_banner(logger)

    # Load configuration
    logger.debug("Loading configuration...")
    config = HookConfig()

    # Check if hook is enabled
    if not config.is_hook_enabled("post_execute"):
        logger.debug("Post-execute hook disabled in configuration")
        return 0

    # Get commands from config
    post_execute_config = config.post_execute
    commands = post_execute_config.get("commands", [])

    if not commands:
        logger.info("No commands configured for post-execute hook")
        logger.info("Edit config.yaml to add commands:")
        logger.info("  post_execute:")
        logger.info("    enabled: true")
        logger.info("    commands:")
        logger.info('      - "echo \'Operation complete!\'"')
        return 0

    # Get working directory
    working_dir = Path.cwd()

    # Execute commands
    logger.info("Working directory: " + str(working_dir))
    logger.info("")

    try:
        success = execute_commands(logger, commands, working_dir)

        logger.log_summary()

        if success:
            logger.success("Post-execute commands: PASSED")
        else:
            logger.warning("Post-execute commands: COMPLETED WITH WARNINGS")

        return 0  # Always succeed, don't block operations

    except Exception as e:
        logger.warning(f"Post-execute hook error: {e}")
        return 0  # Always succeed, don't block operations


if __name__ == "__main__":
    try:
        exit_code = main()
        sys.exit(exit_code)
    except KeyboardInterrupt:
        logger = HookLogger("post-execute")
        logger.warning("\nPost-execute hook interrupted by user")
        sys.exit(130)  # Standard exit code for SIGINT
    except Exception as e:
        logger = HookLogger("post-execute")
        logger.debug(f"Post-execute hook error: {e}")
        sys.exit(0)  # Always succeed, don't block operations
